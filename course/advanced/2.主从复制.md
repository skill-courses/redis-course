# Redis的主从复制

前一节我们学习了Redis的持久化操作，持久化能在一定程度上保证了数据的安全性，即便是服务器宕机的情况下，也可以保证数据的丢失非常少。

但是，在现有企业中80%公司大部分使用的是redis单机服务，在实际的场景当中单一节点的redis容易面临风险。

单机容易面临着如下的单机故障：
* 机器故障：我们部署到一台 Redis 服务器，当发生机器故障时，需要迁移到另外一台服务器并且要保证数据是同步的。而数据是最重要的，如果你不在乎，基本上也就不会使用 Redis了。
* 容量瓶颈：当我们有需求需要扩容 Redis 内存时，从 16G 的内存升到 64G，单机肯定是满足不了。当然，如果你有足够的资金，你可以重新买个128G的新机器。如果是网络带宽呢？读请求远高于写请求的情况呢？如何降低负载呢？

如果你在实际开发中遇到了上面的问题，你可以考虑主从复制的架构。

## 主从复制

![master-slave](https://tva1.sinaimg.cn/large/008i3skNgy1gxshjkcndpj316w0l075f.jpg)

主从复制，是指将一台Redis服务器作为保存数据的主节点(Master)，复制到其他的Redis服务器,称为从节点(slave)。 数据的复制是单向的，只能由主节点到从节点。 一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。

需要注意点额是，在这种架构中，Master节点用于数据的读写操作，其他Slave只能用于读操作。

这种架构的优势在于：

* **数据冗余：** 主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。
* **故障恢复：** 当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。
* **负载均衡：** 在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。
* **读写分离：** 可以用于实现读写分离，主库写、从库读，读写分离不仅可以提高服务器的负载能力，同时可根据需求的变化，改变从库的数量；
* **高可用基石：** 除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。

## 主从复制的原理

在学习同步之前，我们先来学习几个概念：
* **runid(replication ID)**：主服务器运行id，Redis实例在启动时，随机生成一个长度40的唯一字符串来标识当前节点。
* **offset**：复制偏移量。主服务器和从服务器各自维护一个复制偏移量，记录传输的字节数。当主节点向从节点发送N个字节数据时，主节点的offset增加N，从节点收到主节点传来的N个字节数据时，从节点的offset增加N。
* **replication backlog buffer**：复制积压缓冲区。是一个固定长度的FIFO队列，大小由配置参数repl-backlog-size指定，默认大小1MB。需要注意的是该缓冲区由master维护并且有且只有一个，所有slave共享此缓冲区，其作用在于备份最近主库发送给从库的数据。

主从复制以持久化为依据，大体经历三个阶段：

### 建立连接

这个阶段主要是从服务器发出slaveof命令之后，与主服务器如何建立连接，为数据同步做准备的过程。
1. 在slaveof命令执行之后，从服务器根据设置的master的ip地址和端口，创建连向主服务器的socket套接字连接，连接成功后，从服务器会为这个套接字关联一个专门的处理器，用于处理后续的复制工作
2. 建立连接之后，从服务器会向主服务器发送ping命令，确认主服务器是否可用，以及当前是否可用接受处理命令。如果收到主服务器的pong回复说明是可用的，否则有可能是网络超时或主服务器阻塞，从服务器会断开连接发起重连
3. 身份验证。如果主服务器设置了requirepass选项，那么从服务器必须配置masterauth选项，且保证密码一致才能通过验证
4. 身份验证完成之后，从服务器会发送自己的监听端口，主服务器会保存下来。

### 数据同步

在主从服务器建立连接确认各自身份之后，就开始数据同步，从服务器向主服务器发送PSYNC命令，执行同步操作，并把自己的数据库状态更新至主服务器的数据库状态。

Redis的主从同步分为：**完整重同步(full resynchronization)**和**部分重同步(partial resynchronization)**

#### 完整重同步

有两种情况下是完整重同步，一是slave连接上master第一次复制的时候；二是如果当主从断线，重新连接复制的时候, 偏移量已经超过缓存区所缓存的数据，则进行完整重同步。

![full-reync](https://tva1.sinaimg.cn/large/008i3skNgy1gxsrcl57b9j30ey0g1t9z.jpg)

整个过程如下：

1. 从服务器连接主服务器，发送SYNC命令
2. 主服务器接收到SYNC命名后，开始执行bgsave命令生成RDB文件并使用缓冲区记录此后执行的所有写命令
3. 主服务器basave执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令
4. 从服务器收到快照文件后丢弃所有旧数据，载入收到的快照
5. 主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令
6. 从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令

#### 部分重同步

![party-reync](https://tva1.sinaimg.cn/large/008i3skNgy1gxsrlfmlv9j30ea0cj0t0.jpg)

当slave连接到master，会执行PSYNC <runid> <offset>发送记录旧的master的runid（replication ID）和偏移量offset，这样master能够只发送slave所缺的增量部分。但是如果master的复制积压缓存区没有足够的命令记录，或者slave传的runid(replication ID)不对，就会进行完整重同步，即slave会获得一个完整的数据集副本.

PSYNC命令执行完整重同步和部分重同步的流程图:

![redis-full-party-reync](https://tva1.sinaimg.cn/large/008i3skNgy1gxsrnc6rubj30ia0ed0u4.jpg)

### 命令传播

当完成数据同步之后，主从服务器的数据暂时达到一致状态，当主服务器执行了客户端的写命令之后，主从的数据便不再一致。为了能够使主从服务器的数据保持一致性，主服务器会对从服务器执行命令传播操作，即每执行一个写命令就会向从服务器发送同样的写命令。

在命令传播阶段，从服务器会默认以每秒一次的频率向主服务器发送心跳检测
```
REPLCONF ACK <replication_offset>
```

